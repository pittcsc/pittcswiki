---
title: "How to Succeed in CS0441, Discrete Structures"
search_tags: 
  - "441"
---

Preface: *If you want to do well in any course, the bare minimum is attending all lectures and doing all homework assignments.*

## What is Discrete Structures?  

CS 0441 Discrete Structures (discrete mathematics), is the study of mathematical structures that are discrete rather than continuous. This means that the objects within the mathematical structures that you'll learn about are distincly separated values. This course will focus heavily on the integers (which are discrete by nature), whereas a continuous field like calculus focuses on real numbers. Lets start with a birds-eye view of the main topics covered in 441:
- Logic and Proofs
  - This is the theoretical foundation of the course which teaches you how to derive additional information from some given information. Thoroughly understanding the proofing techniques is incredibly important because you will be using these techniques throughout the rest of the course. 
- Sets
  - Sets are unordered collections of distinct objects, which have their own unique properties and laws. An example of a set is **Z**, the set of all integers. Another example is the set V of all vowels, V = {a, e, i, o, u}. So long as our sets contain distinct objects, we can define any set we want!
- Functions
  - Functions are mappings from inputs to outputs, from set A to set B. Functions also have their own properties and sub-topics, such as correspondences and composition. For example, think about the function f(x) = x^2, which maps from Z to Z+, from the set of integers to the set of positive integers.
- Sequences and Summations
  - In contrast to the unordered sets, sequences are ordered structures. Take for example the sequence 0, 1, 1, 2, 3, 5, 8, ... , the well known Fibonacci sequence, where each number is the sum of the two preceding numbers (given first is 0 and second is 1). Summations are the addition of terms over a sequence, and these have handy applications to algorithm analysis. 
- Recursion
  - A more theoretical, mathematical, and proof-focused version of the recursion you've seen in a programming class. 
- Counting
  - Combinatorics, pronounced (com-bin-a-tor-icks), is the study of arranging objects. You'll learn about how many ways you can arrange a number of objects in ordered or unordered arrangements of objects. For example, how many bit strings can be made from a sequence of 8 bits?

## Why do we study discrete mathematics in computer science?  

Since all of a computer's data is represented as discrete bits, (0 or 1), it makes sense that we'd want to be familiar with their properties. You'll find practical applications of discrete math in algorithm analysis, computability theory, cryptography, writing proofs about algorithms, etc. Discrete math is the mathematical foundation that is necessary in order to understand the deeper, theoretical, and more complex topics in computing.

## How to succeed in 441:  

Remember, the goal of higher education is *education*, not getting good grades. The primary goal should be learning and understanding the concepts. Luckily, deep conceptual understanding of course material usually yields a good grade :)  

You don't have to follow all of these guidelines to pass the course, but these are my recommendations if you want to walk away with as much knowledge as possible.

### **High level ideas**

- Have a problem solving mindset.
- Go to office hours.
- Engage with the course material before, during, and after each lecture.
- Practice proofs frequently.
- **You WILL get stuck on many problems.** It's natural and it happens to everybody. Spend time with the problem, get familiar and comfortable with it, and the answer will come to you eventually.  
- If you're *really* stuck, **don't look up the answer on the internet** (especially on a homework, that's cheating, cheating = F in the course). Often times it is helpful to step away from a problem or even sleep on it (one of many reasons to start assignments early).

### **Preparation**

- To specify, this section will be about the preparation you can do before the *semester*. Walking into the first day of lecture with a solid understanding of the course material is a fantastic learning advantage and confidence booster. Before the semester starts, I recommend learning a little bit about discrete math on your own. Regarding depth at which you should read / learn, I recommend going an inch deep and a mile wide. Instead of learning only the *first* course topic in its entirety, learn a little bit about all of the topics. Learning everything about logic and proofs before the semester will just make the first month of class boring, and the learning benefits will be over as soon as the next topic beings (which means your workload will increase quite a bit). If you learn a little bit about every topic, you'll have the learning advantage throughout the entire semester, and your workload will stay more consistent. That being said, if you find yourself excited about a particular topic and you wish to read deeper, do it!!!!

### **Readings**

- I recommend readings the assigned textbook chapter class. Coming to class with a sound understanding of what will be taught in lecture is profoundly helpful. I've always found it beneficial to read ahead before class, then use the lecture as more of a review / study session, that way I never feel like I'm actually studying. You can choose the depth at which to read before class. I usually would read with pretty good depth, trying to understand the core concepts of the reading, and if I couldn't wrap my head around some difficult idea, I'd just wait unitl lecture to learn that topic. If you didn't have the time or energy to do any reading, that's okay. Quickly look through the lecture slides before class to get a glance at the topics and concepts to be covered. You don't want any surprises during lecture! 

### **The textbook**

- *Discrete Mathematics and its Applications* by Kenneth Rosen is a fantastic textbook. The concepts are explained well and there are in-text exercises to get you ready for the end-of-chapter problems. These in text exercises are notated by **EXAMPLE X** in the left margin, and they consist of a small problem followed by a solution. **Try solving the exercises by hand before looking at the solution.** This is a fantastic way to engage with the material before class, even if you only do a few problems. At the end of each chapter is around 50 practice problems, and the solutions to the odd-numbered problems can be found at the end of the book. A free pdf version of the textbook can be found easily. I'm not going to provide the link because that's probably crime, but here's something: https://bit.ly/3wB7BZi

### **Homeworks**

- Start the homeworks as early as possible. You don't want to be stuck having to write 5+ proofs with 3 hours until the submission deadline, trust me. If you get stuck on a problem, move on and finish as many as you can. Then, go to office hours and address the problems that you are stuck on. Also, do the bonus problems.
- *A word of advice from a 441 UTA:* early after your homework is graded, **go to office hours (UTA or prof) and ask *why* you got the problems wrong that you did.** This is helpful for you because it fills in *important* gaps of knowledge that will be needed for exam performance. Also, if you go **soon after the assignment is graded** rather than right before an exam, it prevents crowding during the UTA's office hours. Crowding is stressful for the UTAs and it prevents some students from getting their needs addressed.
- The homeworks will start out pretty easy, but they will ramp up in difficulty very quickly. Once proofs are introduced, homeworks will probably take about twice the amount of that they did before.

### **Studying for exams**

- As with most CS courses, avoid rote memorizaiton. Computer science is very a conceptual field and memorization plays a miniscule role. What's important is understanding the systems / patterns, conceptualization, and problem solving, all of which are skills that can be strengthened with practice. The odd-numbered practice problems at the end of every chapter are very helpful and their answers can be found at the end of the book. 

## Conclusion:

You can learn a *massive* amount of information from this course. You will have better problem solving skills, you'll be better prepared to understand theoretical topics in CS, and your logical thinking will be much more sound. I will admit this is a challenging course, but if you spend enough time engaging with the material you will succeed! Remember, if a course isn't challenging, it's probably not increasing the value of your education.
